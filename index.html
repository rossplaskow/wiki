<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random Wikipedia Articles with Related Next Page</title>
  <!-- Use viewport-fit=cover to allow safe area adjustments -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    /* Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    /* Full-screen layout */
    body {
      background-color: #000;
      font-family: Arial, sans-serif;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    /* API Key overlay */
    #apikey-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #apikey-overlay input {
      padding: 10px;
      width: 80%;
      max-width: 300px;
      font-size: 1em;
      border-radius: 5px;
      border: none;
      margin-top: 20px;
      margin-bottom: 20px;
      autocapitalize: none;
      autocomplete: off;
      spellcheck: false;
      inputmode: text;
    }
    #apikey-overlay button {
      padding: 10px 20px;
      font-size: 1em;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }
    /* Simulated phone screen */
    #phone-container {
      position: relative;
      width: 375px;
      /* Adjust height to account for safe area at the bottom */
      height: calc(100vh - env(safe-area-inset-bottom) - 20px);
      background: #000;
      border: 0;
      border-radius: 40px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(255,255,255,0.1);
      touch-action: none; /* disable native scrolling */
    }
    /* Container for pages */
    #pages {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Instead of subtracting safe-area repeatedly, we apply it once via margin */
      margin-top: 0; /* will be set via JS */
      transition: transform 0.3s ease;
      will-change: transform;
    }
    /* Each full-screen page */
    .page {
      width: 100%;
      height: 100%;
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    /* Title and extract styling */
    .title {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 15px;
    }
    .extract {
      font-size: 1.2em;
      line-height: 1.5;
      /* Multi-line clamping with ellipsis */
      display: -webkit-box;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-line-clamp: 16;
    }
  </style>
</head>
<body>
  <!-- API Key Overlay -->
  <div id="apikey-overlay">
    <h2>OpenAI API Key</h2>
    <input type="text" id="apikey-input" placeholder="sk-..." autocapitalize="none" autocomplete="off" spellcheck="false" inputmode="text">
    <button id="apikey-ok">OK</button>
  </div>

  <!-- Phone Container -->
  <div id="phone-container">
    <div id="pages">
      <!-- Article pages will be appended here -->
    </div>
  </div>

  <script>
    // --- API Key Setup ---
    let openAiApiKey = localStorage.getItem('openAiApiKey') || "";
    const apikeyOverlay = document.getElementById('apikey-overlay');
    const apikeyInput = document.getElementById('apikey-input');
    const apikeyOk = document.getElementById('apikey-ok');
    
    if (openAiApiKey) {
      apikeyOverlay.style.display = 'none';
    }
    
    apikeyOk.addEventListener('click', () => {
      openAiApiKey = apikeyInput.value.trim();
      if (openAiApiKey) {
        localStorage.setItem('openAiApiKey', openAiApiKey);
        apikeyOverlay.style.display = 'none';
        preloadPages(2);
      }
    });
    
    // --- Layout & Variables ---
    const safeAreaTop = parseFloat(getComputedStyle(document.documentElement)
                              .getPropertyValue('env(safe-area-inset-top)')) || 20;
    // Instead of subtracting safeAreaTop in transform, set it as margin-top on #pages.
    const pagesContainer = document.getElementById('pages');
    pagesContainer.style.marginTop = -safeAreaTop + "px";
    
    const phoneContainer = document.getElementById('phone-container');
    const phoneHeight = phoneContainer.clientHeight;
    let activeIndex = 0;
    let startY = 0;
    let isDragging = false;
    
    // For dwell timer and related next page.
    let dwellTimer = null;
    let nextSearchTerm = null;
    
    // --- GPT Call Function ---
    async function fetchRelatedSearchTerm(text) {
      if (!openAiApiKey) return null;
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + openAiApiKey
          },
          body: JSON.stringify({
            model: "chatgpt-4o-latest",
            messages: [
              { role: "system", content: "You are an expert researcher. Provide a single, concise related subject based on the provided Wikipedia article text." },
              { role: "user", content: text }
            ],
            max_tokens: 10,
            temperature: 0.7
          })
        });
        if (!response.ok) throw new Error("OpenAI API request failed");
        const data = await response.json();
        return data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content.trim();
      } catch (error) {
        console.error("Error fetching related term:", error);
        return null;
      }
    }
    
    // --- Article Fetching Functions ---
    async function fetchRandomArticle() {
      try {
        const response = await fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary');
        if (!response.ok) throw new Error('Network response was not ok');
        return await response.json();
      } catch (error) {
        console.error('Error fetching article:', error);
        return { title: 'Error', extract: 'Could not load article.' };
      }
    }
    
    async function fetchArticleByQuery(query) {
      try {
        const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=50&format=json&origin=*`;
        const response = await fetch(searchUrl);
        if (!response.ok) throw new Error("Search request failed");
        const data = await response.json();
        const results = data.query.search;
        if (results && results.length > 0) {
          const randomResult = results[Math.floor(Math.random() * results.length)];
          const summaryUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(randomResult.title)}`;
          const summaryResponse = await fetch(summaryUrl);
          if (!summaryResponse.ok) throw new Error("Summary request failed");
          return await summaryResponse.json();
        } else {
          return await fetchRandomArticle();
        }
      } catch (error) {
        console.error("Error fetching article by query:", error);
        return await fetchRandomArticle();
      }
    }
    
    // Create a page element; if nextSearchTerm is set, use it.
    async function createPage() {
      let article;
      if (nextSearchTerm) {
        article = await fetchArticleByQuery(nextSearchTerm);
        nextSearchTerm = null;
      } else {
        article = await fetchRandomArticle();
      }
      const page = document.createElement('div');
      page.className = 'page';
      
      if (article.content_urls && article.content_urls.desktop && article.content_urls.desktop.page) {
        page.dataset.pageUrl = article.content_urls.desktop.page;
      }
      
      const titleEl = document.createElement('div');
      titleEl.className = 'title';
      titleEl.textContent = article.title || 'No Title';
      
      const extractEl = document.createElement('div');
      extractEl.className = 'extract';
      extractEl.textContent = article.extract || 'No extract available.';
      
      page.appendChild(titleEl);
      page.appendChild(extractEl);
      
      // Double-click (desktop) to open article.
      page.addEventListener('dblclick', () => {
        if (page.dataset.pageUrl) {
          window.open(page.dataset.pageUrl, '_blank');
        }
      });
      
      // Double-tap (mobile) detection.
      let lastTap = 0;
      page.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0) {
          if (page.dataset.pageUrl) {
            window.open(page.dataset.pageUrl, '_blank');
          }
          e.preventDefault();
        }
        lastTap = currentTime;
      });
      
      return page;
    }
    
    async function appendPage() {
      const page = await createPage();
      pagesContainer.appendChild(page);
    }
    
    async function preloadPages(count) {
      for (let i = 0; i < count; i++) {
        await appendPage();
      }
    }
    
    // --- Transform Update ---
    function setTranslateY(translateY, withTransition = false) {
      pagesContainer.style.transition = withTransition ? 'transform 0.3s ease' : 'none';
      pagesContainer.style.transform = `translateY(${translateY}px)`;
    }
    
    // --- Swipe and Dwell Timer Handling ---
    // Touch events:
    phoneContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length !== 1) return;
      isDragging = true;
      startY = e.touches[0].clientY;
      if (dwellTimer) {
        clearTimeout(dwellTimer);
        dwellTimer = null;
      }
      setTranslateY(-activeIndex * phoneHeight, false);
    });
    
    phoneContainer.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      const currentY = e.touches[0].clientY;
      const deltaY = currentY - startY;
      setTranslateY(-activeIndex * phoneHeight + deltaY, false);
    });
    
    phoneContainer.addEventListener('touchend', (e) => {
      if (!isDragging) return;
      isDragging = false;
      const endY = e.changedTouches[0].clientY;
      const deltaY = endY - startY;
      if (Math.abs(deltaY) < 5) {
        setTranslateY(-activeIndex * phoneHeight, true);
        return;
      }
      const threshold = phoneHeight * 0.15;
      if (deltaY < -threshold && activeIndex < pagesContainer.children.length - 1) {
        activeIndex++;
      } else if (deltaY > threshold && activeIndex > 0) {
        activeIndex--;
      }
      setTranslateY(-activeIndex * phoneHeight, true);
      // Always ensure a placeholder next page exists.
      if (activeIndex >= pagesContainer.children.length - 2) {
        appendPage();
      }
    });
    
    // Mouse events for desktop:
    let mouseDown = false;
    let mouseStartY = 0;
    phoneContainer.addEventListener('mousedown', (e) => {
      mouseDown = true;
      mouseStartY = e.clientY;
      if (dwellTimer) {
        clearTimeout(dwellTimer);
        dwellTimer = null;
      }
      setTranslateY(-activeIndex * phoneHeight, false);
    });
    
    phoneContainer.addEventListener('mousemove', (e) => {
      if (!mouseDown) return;
      const deltaY = e.clientY - mouseStartY;
      setTranslateY(-activeIndex * phoneHeight + deltaY, false);
    });
    
    phoneContainer.addEventListener('mouseup', (e) => {
      if (!mouseDown) return;
      mouseDown = false;
      const deltaY = e.clientY - mouseStartY;
      if (Math.abs(deltaY) < 5) {
        setTranslateY(-activeIndex * phoneHeight, true);
        return;
      }
      const threshold = phoneHeight * 0.15;
      if (deltaY < -threshold && activeIndex < pagesContainer.children.length - 1) {
        activeIndex++;
      } else if (deltaY > threshold && activeIndex > 0) {
        activeIndex--;
      }
      setTranslateY(-activeIndex * phoneHeight, true);
      if (activeIndex >= pagesContainer.children.length - 2) {
        appendPage();
      }
    });
    
    phoneContainer.addEventListener('mouseleave', () => {
      if (mouseDown) {
        mouseDown = false;
        setTranslateY(-activeIndex * phoneHeight, true);
      }
    });
    
    // Start a dwell timer when a page is fully in view.
    pagesContainer.addEventListener('transitionend', () => {
      if (dwellTimer) clearTimeout(dwellTimer);
      dwellTimer = setTimeout(async () => {
        // Only proceed if the user is still on the same page.
        const currentPage = pagesContainer.children[activeIndex];
        if (!currentPage) return;
        const titleText = currentPage.querySelector('.title').textContent;
        const extractText = currentPage.querySelector('.extract').textContent;
        const pageText = titleText + ". " + extractText;
        const term = await fetchRelatedSearchTerm(pageText);
        if (term) {
          nextSearchTerm = term;
          console.log("Next search term set to:", nextSearchTerm);
          // If the user is still on the same page and a placeholder next page exists,
          // replace it with a related article.
          if (pagesContainer.children.length > activeIndex + 1) {
            const relatedPage = await createPage();
            // Insert the related page at position activeIndex+1.
            pagesContainer.replaceChild(relatedPage, pagesContainer.children[activeIndex + 1]);
          }
        }
      }, 2000);
    });
    
    // Initial load.
    preloadPages(2);
  </script>
</body>
</html>
